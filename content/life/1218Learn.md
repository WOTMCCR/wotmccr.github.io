---
title: 2025年12月18日 19日 学习记录
created: 2025-12-18
tags:
  - 日记
categories:
  - life
draft: "false"
summary: 不管怎么样总也要总结一下吧,应该是18 19日的总结吧，这几天感觉新题做的有点多？状态不太好，效率有些低了，我需要做更多的整理和输出，做某种程度上也算是输入，有些忽视了基础知识的整理输出了。
---

## Excution Log

- `float()` 会自动判断字符串能否转为数字
	- 能转 → 不报错 → 返回 True
	- 不能转 --> **报错 抛出ValueError异常** 
- 极大极小值
	- `float('inf') / float('-inf')`
- `result = [[i, val] for i, val in enumerate(nums)]`
- `matrix = [[0] * cols for _ in range(rows)]`
- `min(x for x in xs if cond(x))`
- ` s[0:5][: :-1] `
- 把多个函数的返回值 组合成元组 `for palindrome in (extend(i , i) , extend(i , i+1)):`
- `dp = [[False] * n for _ in range(n)]`

## Thinking Log

数学上你在思考“函数值”，  
编程上你必须思考“状态什么时候失效”。

### 复习

**300. 最长递增子序列**
- 动态规划
	- `dp[i]` 代表以 `nums[i]` 结尾的最长递增子序列的长度
		- 因此每个位置的初始值是 1
		- 递推公式为从开始到当前位置的 ，且末尾元素小于当前元素的最大子序列长度 + 1
		- `dp[i] = max( dp[j] + 1 for j in range(i) if nums[j] < nums[i] )`
			- `nums[j] < nums[i]`可能都不满足导致max中没有元素，所以需要设置默认值
- 时间复杂度 O(n^2)
**45. 跳跃游戏 II**
- 贪心 + 动态规划解法
- 动态规划：
	- 也类似于 最长递增子序列 的思想，找一个 有相关关系的子序列
	- `dp[i] 设为 以 nums[i]` 结尾的 最小跳跃次数
	- `dp[i] = min(dp[j] + 1 for j in range(i) if nums[j] + j >= i)`
- 贪心： 找每个跳跃区间，能跳的最远值，作为新的跳跃区间，再找其中的最远值，直到末尾
- 只需要一次遍历，当到达之前的跳跃区间边界的时候，更新跳跃区间边界为最远值，如果大于等于末尾则直接退出
**121. 买卖股票的最佳时机**
- 先来贪心，当前股票的价格 - 之前的最低价格 就是 最佳时机
**122.买卖股票的最佳时机 II**
- 贪心，每一个增长都是利润
- 动态规划
	- 每一个点有两个状态，持有股票，没持有股票
	- `dp[i][0]` 第i天不持有股票的收益: `dp[i][0] = max(dp[i-1][1] + prices[i],dp[i-1][0])`
	- `dp[i][1]` 第i天持有股票的收益 `dp[i][1] = max(dp[i-1][0]) - prices[i],dp[i-1][1]`
**139.单词拆分**
- 从 1 到 n 开始遍历
- `dp[i]` 代表长度为 i 的 单词能否被拆分
- `dp[i] = any(dp[i-len(w)] and s[i-len(w):i] == w for w in wordDict if len(w) <= i)`
42.接雨水
- 单调栈 注意栈中存的是索引

### 新题

1. **打家劫舍** - 一维 DP + 空间优化
	- 偷相邻的 和 不偷相邻的偷这家的 选一个`dp[i] = max(dp[i-1],dp[i-2] + nums[i])`
	- 注意初始化，`dp[1] = max(nums[0],nums[1])`
2. **最长回文子串** - 二维 DP 入门
	- 不要抵触暴力法，当前数据量为 1000 O(n^2)一般而言可以成功
		- 从前往后遍历，对每一个位置判断是否为 回文数的中心
	- 动态规划
		- `dp[i][j] = True/False 表示：s[i:j+1] 这个子串是否是回文`
		- `dp[i][j]` 依赖 `dp[i+1][j-1]` 所以 i从大到小 j 从小到大
3. **零钱兑换** - 完全背包
	- 确定好每个变量的意思 `dp[i] 表示 金额为 i 的零钱是否能够被兑换 ，长度为 amount + 1`
	- 递推公式为 `dp[i] = min((dp[i-coin] + 1 for coin in coins if i >= coin and dp[i-coin] != -1),default = -1)`
4. **分割等和子集** - 01背包
	- 如果物品可以多次使用 则 可以先遍历目标
	- 如果物品不可以多次使用 则 需要**先遍历物品**
		- 内层遍历目标，
			- 如果 正序遍历 相同 num 间隔的 tg 仍然会多次使用同一个num
			- 所以 **倒序遍历** `for tg in range(target , num - 1 , -1)`
				- 直接赋值会覆盖之前已经凑出的结果，所以需要判断 为 true 才赋值
5. 84. 柱状图中最大的矩形
	- 每个矩形都等于 `最矮柱 * 左右第一个小于它的柱子作为的边界`
	- 从栈底到栈顶递增的单调栈，当入栈元素小于栈顶元素，则说明找到了矩形中的最小柱，以及左右边界
	- 加了哨兵可以减少一些处理逻辑
		- **左边 0**：保证所有柱子都有左边界
		- **右边 0**：强制把栈清空，避免漏算面积
