---
categories: 算法题
title: 2024-06-28刷题3
tags:
  - leetcode
  - 动态规划
date: 2024-06-28
---
## 2024-06-28 刷题3
### 188. 买卖股票的最佳时机 IV
16:56
#### 题目描述
最多可以完成k笔交易
#### 思路
思路与之前的相同
只是有k次选择需要2k个状态

#### 复杂度
时间复杂度: O(n * k)，其中 n 为 prices 的长度
空间复杂度: O(n * k)

#### 题解
##### C++
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(k * 2 + 1 , 0));
        //初始化
        for(int i = 1 ; i < 2*k; i+=2){
            dp[0][i] = -prices[0];
        }

        for(int i = 1 ; i < prices.size() ; i++){
            //状态变换
            for(int j = 0 ; j < 2 * k - 1; j+=2){
                //奇数买入保留
                dp[i][j+1] = max(dp[i-1][j+1] , dp[i-1][j] - prices[i]);
                //偶数卖出
                dp[i][j+2] = max(dp[i-1][j+2] , dp[i-1][j+1] + prices[i]);
            }
        }
        return dp[prices.size()-1][2*k];
    }
};
```


### 309. 买卖股票的最佳时机含冷冻期
18:35
#### 题目描述
可以无限次买卖股票，但是卖出之后需要有冷静期
#### 思路
确定dp数组
`dp[i][j]`，第i天状态为j，所剩的最多现金为`dp[i][j]`。
- 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
- 不持有股票状态，这里就有两种卖出股票状态
    - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
    - 状态三：今天卖出股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
![[Pasted image 20240628191548.png]]
j的状态为：
- 0：状态一
- 1：状态二
- 2：状态三
- 3：状态四
##### 确定递推公式
**达到买入股票状态**（状态一）即：`dp[i][0]`，有两个具体操作：
- 操作一：前一天就是持有股票状态（状态一），`dp[i][0] = dp[i - 1][0]`
- 操作二：今天买入了，有两种情况
    - 前一天是冷冻期（状态四），`dp[i - 1][3] - prices[i]`
    - 前一天是保持卖出股票的状态（状态二），`dp[i - 1][1] - prices[i]`
那么`dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])`;

**达到保持卖出股票状态**（状态二）即：`dp[i][1]`，有两个具体操作：
- 操作一：前一天就是状态二
- 操作二：前一天是冷冻期（状态四）
`dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])`;

**达到今天就卖出股票状态**（状态三），即：`dp[i][2]` ，只有一个操作：
昨天一定是持有股票状态（状态一），今天卖出
即：`dp[i][2] = dp[i - 1][0] + prices[i]`;

**达到冷冻期状态**（状态四），即：`dp[i][3]`，只有一个操作：
昨天卖出了股票（状态三）
`dp[i][3] = dp[i - 1][2]`;

#### 复杂度
时间复杂度：O(n)
空间复杂度：O(n)
#### 注意⚠️
#### 题解
##### C++
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        //0 买入持有 ，1卖出可买入 ，2刚卖出，3冷静期
        vector<vector<int>> dp(n , vector<int>(4,0));
        //初始化
        dp[0][0] -= prices[0];
        //遍历天数
        for(int i = 1 ; i < n ; i++){
            //买入前一天必可买或者就是持有状态，或者冷冻期后
            dp[i][0] = max(dp[i-1][0],max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i]));
            //必须前一天是冻结状态
            dp[i][1] = max(dp[i-1][3],dp[i-1][1]);            
            //前一天必是持有状态
            dp[i][2] = dp[i-1][0] + prices[i];
            //必是卖出状态
            dp[i][3] = dp[i-1][2];
        }
        return max(dp[n-1][1],max(dp[n-1][2],dp[n-1][3]));
    }
};
```

### 714. 买卖股票的最佳时机含手续费
19:41
#### 题目描述
每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
#### 思路
再卖出的时候添加手续费
dp数组的含义：
`dp[i][0]` 表示第i天持有股票所省最多现金。 `dp[i][1] `表示第i天不持有股票所得最多现金

如果第i天持有股票即`dp[i][0]`， 那么可以由两个状态推出来
- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`
所以：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])`;

在来看看如果第i天不持有股票即`dp[i][1]`的情况， 依然可以由两个状态推出来
- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，**注意这里需要有手续费了**即：`dp[i - 1][0] + prices[i] - fee`
所以：`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)`;
#### 复杂度
时间复杂度：O(n)
空间复杂度：O(n)
#### 题解
##### C++
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size() , vector<int>(2,0));
        //0持有/买入 ，1卖出
        dp[0][0] = -prices[0];
        for(int i = 1 ; i < prices.size() ; i++){
            dp[i][0] = max(dp[i-1][0] ,dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1] ,dp[i-1][0] + prices[i] - fee);
        }
        return dp[prices.size()-1][1];

    }
};
```
